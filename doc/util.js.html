<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>util.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Animation.html">Animation</a><ul class='methods'><li data-type='method'><a href="Animation.html#atLink">atLink</a></li><li data-type='method'><a href="Animation.html#atUnlink">atUnlink</a></li><li data-type='method'><a href="Animation.html#destroy">destroy</a></li><li data-type='method'><a href="Animation.html#render">render</a></li><li data-type='method'><a href="Animation.html#reset">reset</a></li><li data-type='method'><a href="Animation.html#toString">toString</a></li></ul></li><li><a href="Animator.html">Animator</a></li><li><a href="Bounds.html">Bounds</a><ul class='methods'><li data-type='method'><a href="Bounds.html#contains">contains</a></li><li data-type='method'><a href="Bounds.html#containsXY">containsXY</a></li><li data-type='method'><a href="Bounds.html#copy">copy</a></li><li data-type='method'><a href="Bounds.html#extend">extend</a></li><li data-type='method'><a href="Bounds.html#intersects">intersects</a></li><li data-type='method'><a href="Bounds.html#overlaps">overlaps</a></li></ul></li><li><a href="Evt.html">Evt</a></li><li><a href="FileLoader.html">FileLoader</a></li><li><a href="Game.html">Game</a></li><li><a href="GameState.html">GameState</a><ul class='methods'><li data-type='method'><a href="GameState.html#doinit">doinit</a></li><li data-type='method'><a href="GameState.html#doload">doload</a></li><li data-type='method'><a href="GameState.html#doprepare">doprepare</a></li></ul></li><li><a href="Generator.html">Generator</a></li><li><a href="Gizmo.html">Gizmo</a><ul class='methods'><li data-type='method'><a href="Gizmo.html#atLink">atLink</a></li><li data-type='method'><a href="Gizmo.html#atUnlink">atUnlink</a></li><li data-type='method'><a href="Gizmo.html#destroy">destroy</a></li><li data-type='method'><a href="Gizmo.html#toString">toString</a></li></ul></li><li><a href="GizmoData.html">GizmoData</a><ul class='methods'><li data-type='method'><a href="GizmoData.html#atLink">atLink</a></li><li data-type='method'><a href="GizmoData.html#atUnlink">atUnlink</a></li><li data-type='method'><a href="GizmoData.html#destroy">destroy</a></li><li data-type='method'><a href="GizmoData.html#toString">toString</a></li><li data-type='method'><a href="GizmoData.html#.findInPath">findInPath</a></li><li data-type='method'><a href="GizmoData.html#.findInTrunk">findInTrunk</a></li><li data-type='method'><a href="GizmoData.html#.init">init</a></li><li data-type='method'><a href="GizmoData.html#.path">path</a></li><li data-type='method'><a href="GizmoData.html#.root">root</a></li><li data-type='method'><a href="GizmoData.html#.xspec">xspec</a></li></ul></li><li><a href="Rect.html">Rect</a></li><li><a href="Sfx.html">Sfx</a></li><li><a href="Sketch.html">Sketch</a><ul class='methods'><li data-type='method'><a href="Sketch.html#atLink">atLink</a></li><li data-type='method'><a href="Sketch.html#atUnlink">atUnlink</a></li><li data-type='method'><a href="Sketch.html#destroy">destroy</a></li><li data-type='method'><a href="Sketch.html#render">render</a></li><li data-type='method'><a href="Sketch.html#reset">reset</a></li><li data-type='method'><a href="Sketch.html#toString">toString</a></li></ul></li><li><a href="Sprite.html">Sprite</a></li><li><a href="UiCanvas.html">UiCanvas</a></li><li><a href="UiText.html">UiText</a></li><li><a href="UiView.html">UiView</a></li><li><a href="UpdateSystem.html">UpdateSystem</a></li></ul><h3><a href="global.html">Global</a></h3>
    
</nav>

<div id="main">
    
    <h1 class="page-title">util.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>export { Util };

// =========================================================================
class Util {

    static _update(target, ext) {
        //console.log(`target: ${Fmt.ofmt(target)} exts: ${Fmt.ofmt(ext)}`)
        for (const [k,v] of Object.entries(ext)) {
            // -- handle simple objects
            if (v &amp;&amp; v.constructor &amp;&amp; v.constructor.name === 'Object') {
            // -- handle simple values ... overwrite or assign target property
                target[k] = this._update((k in target) ? target[k] : {}, v);
            } else {
                target[k] = v;
            }
        }
        return target;
    }

    /**
     * update performs a deep copy of the provided extension objects to the target object.
     * All updates are added as extensions to the original object, so nested values in the target are only overwritten if that same path/key is in the extension update
     * @param {*} target 
     * @param  {...any} exts 
     * @returns target
     */
    static update(target, ...exts) {
        if (target &amp;&amp; typeof target === 'object') {
            for (const ext of exts) {
                if (ext &amp;&amp; typeof ext === 'object') {
                    this._update(target, ext);
                }
            }
        }
        return target;
    }

    static *kvWalk(obj, cache=new WeakSet()) {
        if (cache.has(obj)) return;
        if (Array.isArray(obj)) {
            cache.add(obj);
            for (let i=0; i&lt;obj.length; i++) {
                yield [i,obj[i],obj];
                yield *this.kvWalk(obj[i], cache);
            }
        } else if (typeof obj === 'object' &amp;&amp; obj !== null) {
            cache.add(obj);
            for (const [k,v] of Object.entries(obj)) {
                yield [k,v,obj];
                yield *this.kvWalk(v, cache);
            }
        }
    }

    static copy(entity, cache = new WeakMap()) {
        if (cache.has(entity)) return cache.get(entity);
        if (entity instanceof Map) {
            let c = new Map();
            entity.forEach((value, key) => c.set(this.copy(key), this.copy(value)));
            return c;
        }
        if (entity instanceof Set) {
            let c = new Set();
            entity.forEach((value) => c.add(this.copy(value)));
            return c;
        }
        if (Array.isArray(entity)) {
            let c = [];
            entity.forEach((value) => c.push(this.copy(value)));
            return c;
        }
        if (entity.constructor.name === 'Object') {
            let c = {};
            cache.set(entity, c);
            return Object.assign(c, ...Object.keys(entity).map((prop) => ({ [prop]: this.copy(entity[prop], cache) })));
        }
        return entity;
    }

    static arrayBufferToBase64( buffer ) {
        var binary = '';
        var bytes = new Uint8Array(buffer);
        var len = bytes.byteLength;
        for (var i=0; i&lt;len; i++) {
            binary += String.fromCharCode( bytes[i] );
        }
        return btoa( binary );
    }

    static spliceStr(str, index, count, add) {
        var ar = str.split('');
        ar.splice(index, count, add);
        return ar.join('');
    }

}

class xUtil {

    static empty(obj) {
        if (!obj) return true;
        if (this.iterable(obj)) {
            for (const _ of obj) return false;
            return true;
        }
        return (Object.keys(obj).length === 0);
    }

    static basename(path, strip=false) { 
        path = path.replace(/.*\//, '');
        if (strip) path = path.replace(/\..*/, '');
        return path;
    }

    static colorRect(ctx, x, y, boxWidth, boxHeight, fillColor, alpha=1) {
        let origAlpha = ctx.globalAlpha;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y, boxWidth, boxHeight);
        ctx.globalAlpha = origAlpha;
    }

    static colorRectOutline(ctx, x, y, boxWidth, boxHeight, fillColor, alpha=1) {
        let origAlpha = ctx.globalAlpha;
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = fillColor;
        ctx.strokeRect(x, y, boxWidth, boxHeight);
        ctx.globalAlpha = origAlpha;
    }

    static loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.addEventListener("load", () => resolve(img));
            img.addEventListener("error", err => reject(err));
            img.src = src;
        });
    }

    static loadJson(src) {
        return new Promise((resolve, reject) => {
            // read json file contents
            let xhr = new XMLHttpRequest();
            xhr.addEventListener("load", () => {
                let obj = JSON.parse(xhr.responseText);
                resolve(obj)
            });
            xhr.addEventListener("error", err => reject(err));
            xhr.open("GET", src, true);
            xhr.setRequestHeader("Cache-Control", "no-store");
            xhr.send();
        });
    }

    static objKeyValue(obj, key, dflt) {
        return (obj &amp;&amp; obj.hasOwnProperty(key)) ? obj[key] : dflt;
    }

    static bind(obj, ...names) {
        for (const name of names) {
            obj[name] = obj[name].bind(obj);
        }
    }

    static feq(v1, v2) {
        return Math.abs(v1 - v2) &lt; .00001;
    }

    static iterable(obj) {
        if (obj == null) return false;
        if (typeof obj[Symbol.iterator] === 'function') return true;
        return false;
    }

    /*
    static empty(obj) {
        if (!obj) return true;
        if (this.iterable(obj)) {
            for (const _ of obj) return false;
            return true;
        }
        if (obj.length) return false;
        return true;
    }
    */

    static arraysEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return false;
        if (a.length !== b.length) return false;
        for (let i=0; i&lt;a.length; i++) {
            if (a[i] !== b[i]) return false;
        }
        return true;
    }

    static arrayContains(array, obj) {
        if (!obj.equals) return false;
        for (const v of array) {
            if (obj.equals(v)) return true;
        }
        return false;
    }

    static getpath(obj, path, dflt=null) {
        let node = obj;
        for (const key of path.split('.')) {
            if (!node || !node.hasOwnProperty(key)) return dflt;
            node = node[key];
        }
        return (node !== undefined) ? node : dflt;
    }

    static setpath(obj, path, v) {
        let node = obj;
        let ptokens = path.split('.');
        let key = ptokens[ptokens.length-1];
        ptokens = ptokens.slice(0,-1);
        for (const token of ptokens) {
            if (!node.hasOwnProperty(token)) {
                node[token] = {}
            }
            node = node[token];
        }
        node[key] = v;
    }

    static delpath(obj, path) {
        let node = obj;
        let ptokens = path.split('.');
        let key = ptokens[ptokens.length-1];
        ptokens = ptokens.slice(0,-1);
        for (const token of ptokens) {
            if (!node.hasOwnProperty(token)) return;
            node = node[token];
        }
        delete node[key];
    }


    static findBest(items, evalFcn=(v)=>v, cmpFcn=(v1,v2) => v1&lt;v2, filterFcn=(v)=>true, itemFilterFcn=(v)=>true) {
        let bestItem;
        let bestValue;
        for (const item of items) {
            let value = evalFcn(item);
            if (!filterFcn(value)) continue;
            if (!itemFilterFcn(item)) continue;
            if (!bestItem || cmpFcn(value,bestValue)) {
                bestItem = item;
                bestValue = value;
            }
        }
        return bestItem;
    }

    static getOrAssign(obj, tag, dflt=[]) {
        if (tag in obj) return obj[tag];
        obj[tag] = dflt;
        return dflt;
    }

    // Refer to: http://rosettacode.org/wiki/Bitmap/Bresenham's_line_algorithm#JavaScript
    static *pixelsInSegment(x0, y0, x1, y1) {
        let dx = Math.abs(x1 - x0);
        let sx = x0 &lt; x1 ? 1 : -1;
        let dy = Math.abs(y1 - y0);
        let sy = y0 &lt; y1 ? 1 : -1; 
        let err = (dx>dy ? dx : -dy)/2;        
        while (true) {
            yield [x0,y0];
            if (x0 === x1 &amp;&amp; y0 === y1) break;
            var e2 = err;
            if (e2 > -dx) { 
                err -= dy; 
                x0 += sx; 
            }
            if (e2 &lt; dy) { 
                err += dx; 
                y0 += sy; 
            }
        }
    }

    static *pixelsInCross(x, y, dir, width) {
        let ortho = Direction.orthogonal(dir);
        let x0 = Math.round(x-Math.abs(Direction.asX(ortho)*width/2));
        let y0 = Math.round(y-Math.abs(Direction.asY(ortho)*width/2));
        let x1 = Math.floor(x+Math.abs(Direction.asX(ortho)*width/2));
        let y1 = Math.floor(y+Math.abs(Direction.asY(ortho)*width/2));
        yield *this.pixelsInSegment(x0, y0, x1, y1);
    }

    static getSegmentIntersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) {
        let s1_x = p1_x - p0_x;     
        let s1_y = p1_y - p0_y;
        let s2_x = p3_x - p2_x;     
        let s2_y = p3_y - p2_y;
        let s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
        let t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
        // collision detected
        if (s >= 0 &amp;&amp; s &lt;= 1 &amp;&amp; t >= 0 &amp;&amp; t &lt;= 1) {
            return {x: p0_x + (t * s1_x), y: p0_y + (t * s1_y)};
        }
        // no collision
        return null;
    }

    static *pixelsInSegmentWidth(x0, y0, x1, y1, width) {
        if (width &lt;= 1) {
            yield *this.pixelsInSegment(x0, y0, x1, y1);
            return;
        }
        // compute angle and perpindicular
        let angle = Mathf.angle(x0, y0, x1, y1, true);
        let pangle = angle + Math.PI / 2;
        // there are four points that create a rectangle
        let hw = (width / 2) - .5;
        let dx = Math.cos(pangle) * hw;
        let dy = Math.sin(pangle) * hw;
        let r0x = x0 + dx;
        let r0y = y0 + dy;
        let r1x = x0 - dx;
        let r1y = y0 - dy;
        let r2x = x1 + dx;
        let r2y = y1 + dy;
        let r3x = x1 - dx;
        let r3y = y1 - dy;
        let mini = Math.floor(Math.min(r0x, r1x, r2x, r3x));
        let maxi = Math.round(Math.max(r0x, r1x, r2x, r3x));
        let minj = Math.floor(Math.min(r0y, r1y, r2y, r3y));
        let maxj = Math.round(Math.max(r0y, r1y, r2y, r3y));
        // sweep rectangle
        if (Math.abs(angle) &lt; Math.PI*.25 || Math.abs(angle) > Math.PI*.75) {
            // -- sweep full i range
            for (let i = mini; i &lt;= maxi; i++) {
                let iminj = maxj;
                let imaxj = minj;
                for (const [s0x, s0y, s1x, s1y] of [
                    [r0x, r0y, r2x, r2y],
                    [r0x, r0y, r1x, r1y],
                    [r3x, r3y, r2x, r2y],
                    [r3x, r3y, r1x, r1y]
                ]) {
                // check for segment to sweep intersection
                let intersection = this.getSegmentIntersection(s0x, s0y, s1x, s1y, i, minj-1, i, maxj+1);
                if (intersection) {
                    let j = Math.round(intersection.y);
                    if (j > imaxj) imaxj = j;
                    if (j &lt; iminj) iminj = j;
                }
                }
                // -- sweep j range based on detected intersections
                for (let j = iminj; j &lt;= imaxj; j++) {
                    yield [i, j];
                }
            }

        } else {
            // -- sweep full j range
            for (let j = minj; j &lt;= maxj; j++) {
                let imini = maxi;
                let imaxi = mini;
                for (const [s0x, s0y, s1x, s1y] of [
                    [r0x, r0y, r2x, r2y],
                    [r0x, r0y, r1x, r1y],
                    [r3x, r3y, r2x, r2y],
                    [r3x, r3y, r1x, r1y]
                ]) {
                // check for segment to sweep intersection
                let intersection = this.getSegmentIntersection(s0x, s0y, s1x, s1y, mini-1, j, maxi+1, j);
                if (intersection) {
                    let i = Math.round(intersection.x);
                    if (i > imaxi) imaxi = i;
                    if (i &lt; imini) imini = i;
                }
                }
                // -- sweep i range based on detected intersections
                for (let i = imini; i &lt;= imaxi; i++) {
                    yield [i, j];
                }
            }
        }

    }


}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
