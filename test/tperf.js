import { EvtSystem, ExtEvtEmitter, ExtEvtReceiver } from '../js/event.js';
import { Fmt } from '../js/fmt.js';
import { Schema } from '../js/schema.js';
import { Vect } from '../js/vect.js';

class tdata {
    static registry = {};
    static init() {
        if (!this.name in this.registry) {
            this.registry[this.name] = this;
        }
    }
    constructor(spec={}, applySchema=true) {
        this.constructor.init();
    }
}

class handler {
    constructor(pspec, pclass, node) {
        this.pspec = pspec;
        this.pclass = pclass;
        this.node = node;
        this.links = new Map();
        this.get = this.iget;
        this.set = this.iset;
        this.pathEventable = true;
        this.pathUpdatable = false;
        this.pathAutogen = false;
        this.pathReadonly = false;
    }

    linkUpdate(trunk, link) {
        if (trunk) {
            this.pathEventable = link.schema.eventable && trunk.pathEventable;
            this.pathUpdatable = !link.schema.nopathgen && (link.schema.atUpdate || trunk.pathUpdatable);
            this.pathAutogen = (link.schema.autogendeps.size || trunk.pathAutogen);
            this.pathReadonly = link.schema.readonly || trunk.pathReadonly;
        } else {
            this.pathEventable = true;
            this.pathUpdatable = false;
            this.pathAutogen = false;
            this.pathReadonly = false;
        }
        for (const aschema of Object.values(this.node.constructor.schema)) {
            let att = this[aschema.key];
            if (att && att instanceof tproxy) {
                let link = att.$linker.links.get(this);
                att.$linker.linkUpdate(this, att, link);
            }
        }
    }

    // -- defines method to set new trunk link
    /**
     * @param {linker} trunk 
     * @param {schema} schema 
     * @param {*} keyer 
     */
    link(trunk, schema, keyer) {
        if (tproxy.findInPath(trunk.proxy, (gzd) => gzd === this.proxy)) {
            console.error(`hierarchy loop detected ${this.node} already in trunk: ${trunk}`);
            return;
        }
        let link = { schema: schema, keyer: keyer };
        this.links.set(trunk, link);
        console.log(`-- setting link for ${this.node}`);
        // update path variables for this node and all dependent branch nodes
        this.linkUpdate(trunk, link)
        this.node.atLink(trunk.proxy);
        // regenerate updates to autogenerated fields
        /*
        for (const agk of this.constructor.$autogenKeys) {
            let agschema = this.constructor.schema[agk];
            if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
            // reset autogenerated value to default, setter will take care of updating value
            if (agk in this) this[agk] = '#autogen#';
        }
        if (this.$pathAutogen) {
            for (const gzt of this.constructor.eachInPath(this, (gzn) => (gzn.$schema && gzn.$schema.autogendeps.size))) {
                for (const agk of gzt.$schema.autogendeps) if (agk in gzt.$trunk) gzt.$trunk[agk] = '#autogen#';
            }
        }
        */

    }

    unlink(trunk) {

        // -- defines method to unset trunk link
        Object.defineProperty(this, '$unlink', {
            get: () => (() => {
                let oldTrunk = trunk;
                trunk = null;
                schema = null;
                // update path variables for this node and all dependent branch nodes
                this.$linkUpdate()
                this.atUnlink(oldTrunk);
                // regenerate updates to autogenerated fields
                for (const agk of this.constructor.$autogenKeys) {
                    let agschema = this.constructor.schema[agk];
                    if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
                    // reset autogenerated value to default, setter will take care of updating value
                    if (agk in this) this[agk] = '#autogen#';
                }
            }),
        })

    }
        
    passthruGet(target, key, receiver) {
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return value;
    }
    passthruSet(target, key, value) {
        target[key] = value;
        return true;
    }
    iget(target, key, receiver) {
        //let schema = this.pclass.schema[key];
        let schema = this.node.constructor.schema[key];
        if (schema && schema.getter) return schema.getter(target, this.pspec);
        //console.log(`key: ${key.toString()} this: ${this}`);
        if (key === '$linker') return this;
        if (key === '$target') return target;
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return target[key];
    };
    iset(target, key, value) {
        //let schema = this.pclass.schema[key];
        let schema = this.node.constructor.schema[key];
        console.log(`-- target: ${target} schema: ${schema}`);
        if (!schema && !Object.is(target[key], value)) {
            target[key] = value;
            return true;
        }
        if (schema.setter) {
            value = schema.setter(target, this.pspec, value);
        }
        let storedValue = target[key];
        if (!Object.is(storedValue, value)) {
            if (schema.link) {
                if (storedValue) storedValue.$linker.unlink(this);
                target[key] = value;
                if (value) value.$linker.link(this, schema);
            } else {
                target[key] = value;
            }
        }

        // trigger update if attribute is eventable
        /*
        if (schema && schema.eventable && this.pathEventable) {
            // find event emitter in path
            let root = gzd.constructor.root(gzd);
            // emit
            if (EvtSystem.isEmitter(root)) {
                let path = gzd.constructor.path(gzd);
                let key = (path) ? `${path}.${schema.key}` : schema.key;
                let renderable = schema.renderable || gzd.constructor.findInPath(gzd, (gzn) => gzn.$schema && gzn.$schema.renderable);                             
                EvtSystem.trigger(root, 'gizmo.set', { set: { [key]: storedValue }, render: renderable });
            }
        }
        */

        return true;
    };
}

class tproxy {

    /**
     * root returns the root of the given GizmoData structure (if any)
     * @param {GizmoData} gzd - The object to find the root for
     * @returns {GizmoData} - The root of the GizmoData chain (if any)
     */
    static *roots(gzd) {
        //console.log(`gzd: ${gzd}`);
        //console.log(`gzd.$linker: ${gzd.$linker}`);
        //console.log(`gzd.$linker.size: ${gzd.$linker.links.size}`);
        if (!gzd || !gzd.$linker) return;
        if (!gzd.$linker.links.size) {
            yield gzd;
        } else {
            for (const trunk of gzd.$linker.links.keys()) {
                console.log(`trunk: ${trunk} cls: ${trunk.constructor.name} proxy: ${trunk.proxy}`);
                yield *this.roots(trunk.proxy);
            }
        }
    }

    /**
     * findinTrunk attempts to find a GizmoData node matching the given filter in the trunk (parent nodes) of the given GizmoData object.
     * @param {GizmoData} gzd - The object to start the search at.
     * @param {GizmoData~filter} filter - predicate filter function to apply to each node in the trunk to determine a match
     * @returns {GizmoData} - the first trunk node that matches the filter, otherwise null.
     */
    static findInTrunk(gzd, filter) {
        if (!gzd.$linker || !gzd.$linker.links.size) return null;
        let trunks = Array.from(gzd.$linker.links.keys());
        for (const trunk of trunks) {
            if (filter(trunk)) return trunk;
            if (trunk.$linker && trunk.$linker.links.size) trunks.unshift(trunk.$linker.links.keys());
        }
        return null;
    }

    /**
     * findinPath attempts to find a GizmoData node matching the given filter in the trunk (parent nodes) of the given GizmoData object.
     * @param {GizmoData} gzd - The object to start the search at.
     * @param {GizmoData~filter} filter - predicate filter function to apply to each node in the trunk to determine a match
     * @returns {GizmoData} - the first trunk node that matches the filter, otherwise null.
     */
    static findInPath(gzd, filter) {
        if (filter(gzd)) return gzd;
        return this.findInTrunk(gzd);
    }

    static registry = new Map();
    static init() {
        this.registry.set(this.name, this);
    }
    static get schema() {
        if (!this.hasOwnProperty('_schema')) this._schema = Object.assign({}, Object.getPrototypeOf(this)._schema);
        return this._schema;
    }
    static get schemas() {
        if (!this.hasOwnProperty('_schemas')) this._schemas = Object.values(this.schema);
        return this._schemas;
    }
    constructor(spec={}) {
        this.constructor.init();
        let linker = new handler(spec, this.constructor, this);
        let proxy = new Proxy(this, linker);
        linker.proxy = proxy;
        for (const schema of this.constructor.schemas) {
            proxy[schema.key] = schema.parser(this, spec);
        }
        return proxy;
    }
    atLink(trunk) {
    }
    atUnlink(trunk) {
    }
    toString() {
        return Fmt.toString(this.constructor.name);
    }
}

class tVect1 extends Vect { }

class tVect2 {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
}

class tVect3 {
    static registry = {};
    static init() {
        if (!this.name in this.registry) {
            this.registry[this.name] = this;
        }
    }
    constructor(x,y) {
        this.constructor.init();
        this.x = x;
        this.y = y;
    }
}

class tVect4 extends tdata {
    constructor(x,y) {
        super();
        Object.defineProperty(this, 'x', {
            enumerable: true,
            get: () => x,
            set: (v) => x = v,
        });
        Object.defineProperty(this, 'y', {
            enumerable: true,
            get: () => y,
            set: (v) => y = v,
        });
    }
}

class tVect5 extends tproxy {
    static {
        Schema.apply(this, 'x', { dflt: 0 });
        Schema.apply(this, 'y', { dflt: 0 });
    }
    constructor(x=0,y=0) {
        return super({x:x, y:y});
    }
}

const clss = [
    tVect1,
    tVect2,
    tVect3,
    tVect4,
    tVect5,
]

const iterations = 250000;
//const iterations = 1000000;
//const iterations = 2500000;

xdescribe('perf tests', () => {

    it('performance to construct a vector', ()=>{
        for (const cls of clss) {
            let tag = `constructor test:${cls.name}`;
            console.time(tag);
            for (var i = 0; i < iterations; i++) {
                let v = new cls(1,2);
            };
            console.timeEnd(tag)
        }
    });

    it('performance to get property', ()=>{
        for (const cls of clss) {
            let tag = `get test:${cls.name}`;
            let v = new cls(1,2);
            console.time(tag);
            let x;
            for (var i = 0; i < iterations; i++) {
                x = v.x;
            };
            console.timeEnd(tag)
            expect(x).toEqual(1);
        }
    });

    it('performance to set property', ()=>{
        for (const cls of clss) {
            let tag = `set test:${cls.name}`;
            let v = new cls(1,2);
            console.time(tag);
            for (var i = 0; i < iterations; i++) {
                v.x = 5;
            };
            console.timeEnd(tag)
            expect(v.x).toEqual(5);
        }
    });

});


describe('tproxy tests', () => {
    xit('data changes trigger events', ()=>{
        class TData extends tproxy {
            static { Schema.apply(this, 'data'); }
            static { ExtEvtEmitter.apply(this) }
        };
        /*
        class TGizmoData extends GizmoData {
            static { 
                Schema.apply(this, 'sub', { link: true });
                ExtEvtEmitter.apply(this)
            };
        };
        */
        let o = new TData({data: 'foo'});
        expect(o.data).toEqual('foo');
        let receiver = ExtEvtReceiver.gen();
        let tevt;
        EvtSystem.listen(o, receiver, 'gizmo.set', (evt) => tevt = evt);
        o.data = 'bar';
        expect(tevt.tag).toEqual('gizmo.set');
        expect(tevt.actor).toBe(o);
        expect(tevt.set['data']).toEqual('bar');
    });

    it('can be linked', ()=>{
        class TSub extends tproxy {
            static { Schema.apply(this, 'data'); };
        };
        class TData extends tproxy {
            static { Schema.apply(this, 'sub', { link: true }); };
        };
        let o = new TData({sub: new TSub({data: 'foo'})});
        expect(o.sub.data).toEqual('foo');
    });

    it('can lookup roots', ()=>{
        class TSub extends tproxy {
            static { Schema.apply(this, 'data'); };
        };
        class TData extends tproxy {
            static { Schema.apply(this, 'sub', { link: true }); };
        };
        let o = new TData({sub: new TSub({data: 'foo'})});
        expect(Array.from(TData.roots(o))).toEqual([o]);
        expect(Array.from(TData.roots(o.sub))).toEqual([o]);
    });

});
