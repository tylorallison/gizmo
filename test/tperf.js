import { EvtSystem } from '../js/event.js';
import { Fmt } from '../js/fmt.js';
import { GizmoData } from '../js/gizmoData.js';
//import { GizmoDataW } from '../js/gizmoDataW.js';
import { Schema } from '../js/schema.js';
//import { Vect } from '../js/vect.js';

class tdata {
    static registry = {};
    static init() {
        if (!this.name in this.registry) {
            this.registry[this.name] = this;
        }
    }
    constructor(spec={}, applySchema=true) {
        this.constructor.init();
    }
}

class handler {
    static root(node) {
        while (node) {
            if (node.trunk) {
                node = node.trunk;
            } else {
                return node;
            }
        }
        return null;
    }

    static findInTrunk(node, filter) {
        for (let trunk=node.trunk; trunk; trunk=trunk.trunk) {
            if (filter(trunk)) return trunk;
        }
        return null;
    }

    static findInPath(node, filter) {
        for (let trunk=node; trunk; trunk=trunk.trunk) {
            if (filter(trunk)) return trunk;
        }
        return null;
    }

    static path(node) {
        let path = null;
        while (node.trunk) {
            let key = node.keyer();
            path = (path) ? `${key}.${path}` : key;
            node = node.trunk;
        }
        return path;
    }

    constructor(pspec, pclass, node) {
        this.pspec = pspec;
        this.pclass = pclass;
        this.node = node;
        this.trunk = null;
        this.proxy = null;
        this.schema = null;
        this.keyer = () => (this.schema) ? this.schema.key : '';
        this.get = this.iget;
        this.set = this.iset;
        this.pathEventable = EvtSystem.isEmitter(pclass.schema);
        this.pathUpdatable = false;
        this.pathAutogen = false;
        this.pathReadonly = false;
        this.pathRenderable = false;
    }

    linkUpdate() {
        let trunk = this.trunk;
        if (trunk) {
            this.pathEventable = this.schema.eventable && trunk.pathEventable;
            this.pathUpdatable = !this.schema.nopathgen && (this.schema.atUpdate || trunk.pathUpdatable);
            this.pathAutogen = (this.schema.autogendeps.size || trunk.pathAutogen);
            this.pathReadonly = this.schema.readonly || trunk.pathReadonly;
            this.pathRenderable = this.schema.renderable || trunk.pathRenderable;
        } else {
            this.pathEventable = true;
            this.pathUpdatable = false;
            this.pathAutogen = false;
            this.pathReadonly = false;
            this.pathRenderable = false;
        }
        for (const aschema of Object.values(this.node.constructor.schema)) {
            let att = this[aschema.key];
            if (att && att instanceof tproxy) {
                att.$linker.linkUpdate();
            }
        }
    }

    // -- defines method to set new trunk link
    /**
     * @param {linker} trunk 
     * @param {schema} schema 
     * @param {*} keyer 
     */
    link(trunk, schema, keyer) {
        if (tproxy.findInPath(trunk.proxy, (gzd) => gzd === this.proxy)) {
            console.error(`hierarchy loop detected ${this.node} already in trunk: ${trunk}`);
            return;
        }
        // set link
        this.trunk = trunk;
        this.schema = schema;
        if (keyer) this.keyer = keyer;
        // update path variables for this node and all dependent branch nodes
        this.linkUpdate()
        this.node.atLink(trunk.proxy);
        // regenerate updates to autogenerated fields
        /*
        for (const agk of this.constructor.$autogenKeys) {
            let agschema = this.constructor.schema[agk];
            if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
            // reset autogenerated value to default, setter will take care of updating value
            if (agk in this) this[agk] = '#autogen#';
        }
        if (this.$pathAutogen) {
            for (const gzt of this.constructor.eachInPath(this, (gzn) => (gzn.$schema && gzn.$schema.autogendeps.size))) {
                for (const agk of gzt.$schema.autogendeps) if (agk in gzt.$trunk) gzt.$trunk[agk] = '#autogen#';
            }
        }
        */

    }

    unlink() {
        let trunk = this.trunk;
        this.trunk = null;
        this.schema = null;
        this.keyer = null;
        this.linkUpdate()
        this.node.atUnlink(trunk);

        // regenerate updates to autogenerated fields
        /*
        for (const agk of this.constructor.$autogenKeys) {
            let agschema = this.constructor.schema[agk];
            if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
            // reset autogenerated value to default, setter will take care of updating value
            if (agk in this) this[agk] = '#autogen#';
        }
        */

    }
        
    pget(target, key, receiver) {
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return value;
    }
    pset(target, key, value) {
        target[key] = value;
        return true;
    }
    iget(target, key, receiver) {
        //let schema = this.pclass.schema[key];
        let schema = this.node.constructor.schema[key];
        if (schema && schema.getter) return schema.getter(target, this.pspec);
        //console.log(`key: ${key.toString()} this: ${this}`);
        if (key === '$linker') return this;
        if (key === '$target') return target;
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return target[key];
    };
    iset(target, key, value) {
        //let schema = this.pclass.schema[key];
        let schema = this.node.constructor.schema[key];
        if (!schema && !Object.is(target[key], value)) {
            target[key] = value;
            return true;
        }
        if (schema.setter) {
            value = schema.setter(target, this.pspec, value);
        }
        let storedValue = target[key];
        if (!Object.is(storedValue, value)) {
            if (schema.link) {
                if (storedValue) storedValue.$linker.unlink();
                target[key] = value;
                if (value) value.$linker.link(this, schema);
            } else {
                target[key] = value;
            }
        }

        // trigger update if attribute is eventable
        if (schema && schema.eventable && this.pathEventable) {
            // find event emitter in path
            let root = target.constructor.root(this.proxy);
            // emit
            if (EvtSystem.isEmitter(root)) {
                let path = this.constructor.path(this);
                let key = (path) ? `${path}.${schema.key}` : schema.key;
                let renderable = schema.renderable || this.pathRenderable;
                EvtSystem.trigger(root, 'gizmo.set', { set: { [key]: value }, render: renderable });
            }
        }

        return true;
    };
}

class tVect1 extends GizmoData { 
    static {
        Schema.apply(this, 'x', { dflt: 0 });
        Schema.apply(this, 'y', { dflt: 0 });
    }
    constructor(x,y) {
        super({x:x, y:y});
    }
}

class tVect2 {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
}

class tVect3 {
    static {
        Schema.apply(this, 'x', { dflt: 0 });
        Schema.apply(this, 'y', { dflt: 0 });
    }
    static registry = {};
    static init() {
        if (!this.name in this.registry) {
            this.registry[this.name] = this;
        }
    }
    constructor(x,y) {
        this.constructor.init();
        GizmoData.parser(this, {x:x, y:y});
        //this.x = x;
        //this.y = y;
    }
}

class tVect4 extends tdata {
    constructor(x,y) {
        super();
        Object.defineProperty(this, 'x', {
            enumerable: true,
            get: () => x,
            set: (v) => x = v,
        });
        Object.defineProperty(this, 'y', {
            enumerable: true,
            get: () => y,
            set: (v) => y = v,
        });
    }
}

class tVect5 {
    static {
        Schema.apply(this, 'x', { dflt: 0 });
        Schema.apply(this, 'y', { dflt: 0 });
    }
    static registry = {};
    static init() {
        if (!this.name in this.registry) {
            this.registry[this.name] = this;
        }
    }
    constructor(x,y) {
        //this.x = x;
        //this.y = y;
        this.constructor.init();
        GizmoData.parser(this, {x:x, y:y});
        let proxy = new Proxy(this, {
            get(target, key, receiver) {
                const value = target[key];
                if (value instanceof Function) {
                    return function (...args) {
                        return value.apply(this === receiver ? target : this, args);
                    };
                }
                return value;
            },
            set(target, key, value) {
                target[key] = value;
                return true;
            }
        });
        return proxy;
    }
}

class tVect6 {
    constructor(x,y) {
        this.x = x;
        this.y = y;
        let proxy = new Proxy(this, {
            get(target, prop, receiver) {
                return Reflect.get(...arguments);
            },
            set(target, prop, receiver) {
                let success = Reflect.set(...arguments);
                return success;
            }
        });
        return proxy;
    }
}

class AttHandle {
    constructor(key) {
        this.key = key;
        this.getter = (t) => t[key];
        this.modifier = undefined;
        this.setter = (t,v) => t[key] = v,
        this.watchers = undefined;
        this.pwatchers = undefined;
    }
    addWatcher(watcher, pri=0) {
        if (!this.watchers) {
            this.watchers = [ watcher ];
            this.pwatchers = [ pri ];
        } else {
            let idx=0;
            for ( ; idx <= this.watchers.length && this.pwatchers[idx] <= pri; i++ );
            this.watchers.splice(idx, 0, watcher);
            this.pwatchers.splice(idx, 0, pri);
        }
    }
    delWatcher(watcher) {
        let idx = this.watchers.indexOf(watcher);
        if (idx !== -1) {
            this.watchers.splice(idx, 1);
            this.pwatchers.splice(idx, 1);
        }
        if (!this.watchers.length) {
            this.watchers = null;
            this.pwatchers = null;
        }
    }
    get(target) {
        return this.getter(target);
    }
    set(target, value) {
        const ov = this.getter(target);
        if (this.modifier) value = this.modifier(target, value);
        this.setter(target, value);
        if (this.watchers) {
            for (const watcher of this.watchers) watcher(t,ov, value);
        }
    }
}

class tVect7 {
    constructor(x,y) {
        this.x = x;
        this.y = y;

        let handler = {
            handles: {
                x: new AttHandle('x'),
                y: new AttHandle('y'),
            },
            get(target, key, receiver) {
                const value = target[key];
                if (value instanceof Function) {
                    return function (...args) {
                        return value.apply(this === receiver ? target : this, args);
                    };
                }
                let hdl = this.handles[key];
                if (hdl) return hdl.get(target);
                return undefined;
                //return value;
            },
            set(target, key, value) {
                let hdl = this.handles[key];
                if (hdl) hdl.set(target, value);
                return true;
                for (const setter of this.setters) {
                    setter(target, key, value);
                }
                //target[key] = value;
                return true;
            }
        };

        let proxy = new Proxy(this, handler);
        return proxy;
    }
}

class tVect8 extends GizmoData {
    static {
        Schema.apply(this, 'x', { dflt: 0 });
        Schema.apply(this, 'y', { dflt: 0 });
    }
    constructor(x,y) {
        super({x:x, y:y});
    }
}

const clss = [
    tVect1,
    tVect2,
    tVect3,
    //tVect4,
    tVect5,
    //tVect6,
    //tVect7,
    tVect8,
]

//const iterations = 250000;
const iterations = 1000000;
//const iterations = 1;
//const iterations = 2500000;

describe('perf tests', () => {

    it('performance to construct a vector', ()=>{
        for (const cls of clss) {
            let tag = `constructor test:${cls.name}`;
            console.time(tag);
            for (var i = 0; i < iterations; i++) {
                let v = new cls(1,2);
            };
            console.timeEnd(tag)
        }
    });

    it(`performance to get property`, ()=>{
        for (const cls of clss) {
                let tag = `get test:${cls.name}`;
                let v = new cls(1,2);
                console.time(tag);
                let x;
                for (var i = 0; i < iterations; i++) {
                    x = v.x;
                };
                console.timeEnd(tag)
                expect(x).toEqual(1);
        }
    });

    it('performance to set property', ()=>{
        for (const cls of clss) {
            let tag = `set test:${cls.name}`;
            let v = new cls(1,2);
            console.time(tag);
            for (var i = 0; i < iterations; i++) {
                v.x = i;
            };
            console.timeEnd(tag)
            expect(v.x).toEqual(iterations-1);
        }
    });

});