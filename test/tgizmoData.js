import { EvtSystem, ExtEvtEmitter, ExtEvtReceiver } from '../js/event.js';
import { GizmoData } from '../js/gizmoData.js';
import { Schema } from '../js/schema.js';

describe('gizmo data', () => {

    it('attributes become readonly when attached to readonly GizmoData', ()=>{
        class TLeaf extends GizmoData {
            static { 
                Schema.apply(this, 'el'); 
            };
        };
        class TRO extends GizmoData {
            static { 
                Schema.apply(this, 'leaf', { link: true, readonly: true }); 
            };
        };
        let leaf = new TLeaf({el: 'hello'});
        leaf.el = 'there';
        expect(leaf.el).toEqual('there');
        let ro = new TRO({ leaf: leaf });
        leaf.el = 'again';
        expect(leaf.el).toEqual('there');
        leaf.$unlink();
        leaf.el = 'once more';
        expect(leaf.el).toEqual('once more');
    });

    it('can trigger trunk update on child update', ()=>{
        let subUpdate = {};
        let rootUpdate = {};
        class TLeaf extends GizmoData {
            static { 
                Schema.apply(this, 'el'); 
            };
        };
        class TSub extends GizmoData {
            static { 
                Schema.apply(this, 'leaf', { link: true }); 
            };
        };
        class TSubUpdate extends GizmoData {
            static { 
                Schema.apply(this, 'leaf', { atUpdate: (r,o,k,ov,nv) => subUpdate = { ov: ov, nv: nv }, link: true }); 
            };
        };
        class TRoot extends GizmoData {
            static { 
                Schema.apply(this, 'sub', { atUpdate: (r,o,k,ov,nv) => rootUpdate = { ov: ov, nv: nv }, link: true }); 
            };
        };
        let leaf = new TLeaf({el: 'hello'});
        let sub = new TSub();
        let subu = new TSubUpdate();
        let root = new TRoot();
        leaf.el = 'there';
        expect(subUpdate).toEqual({});
        expect(rootUpdate).toEqual({});
        sub.leaf = leaf;
        leaf.el = 'leaf1';
        expect(subUpdate).toEqual({});
        expect(rootUpdate).toEqual({});
        root.sub = sub;
        leaf.el = 'sub1';
        expect(subUpdate).toEqual({});
        expect(rootUpdate).toEqual({ov: 'leaf1', nv: 'sub1'});
        rootUpdate = {};
        subu.leaf = leaf;
        leaf.el = 'leaf2';
        expect(subUpdate).toEqual({ov: 'sub1', nv: 'leaf2'});
        expect(rootUpdate).toEqual({});
        subUpdate = {};
        root.sub = subu;
        leaf.el = 'sub2';
        expect(subUpdate).toEqual({ov: 'leaf2', nv: 'sub2'});
        expect(rootUpdate).toEqual({ov: 'leaf2', nv: 'sub2'});
    });

    it('can be registered', ()=>{
        let cls = class TRegister extends GizmoData {};
        let o = new cls;
        expect(GizmoData.registry.hasOwnProperty('TRegister')).toBeTruthy();
    });

    it('can be linked', ()=>{
        class TGizmoDataSub extends GizmoData {
            static { Schema.apply(this, 'data'); };
        };
        class TGizmoData extends GizmoData {
            static { Schema.apply(this, 'sub', { link: true }); };
        };
        let o = new TGizmoData({sub: new TGizmoDataSub({data: 'foo'})});
        expect(o.sub.data).toEqual('foo');
    });

    it('data changes trigger events', ()=>{
        class TGizmoDataSub extends GizmoData {
            static { Schema.apply(this, 'data'); };
        };
        class TGizmoData extends GizmoData {
            static { 
                Schema.apply(this, 'sub', { link: true });
                ExtEvtEmitter.apply(this)
            };
        };
        let o = new TGizmoData({sub: new TGizmoDataSub({data: 'foo'})});
        expect(o.sub.data).toEqual('foo');
        let receiver = ExtEvtReceiver.gen();
        let tevt;
        EvtSystem.listen(o, receiver, 'gizmo.set', (evt) => tevt = evt);
        o.sub.data = 'bar';
        //EvtSystem.trigger(emitter, 'test');
        expect(tevt.tag).toEqual('gizmo.set');
        expect(tevt.actor).toBe(o);
        expect(tevt.set['sub.data']).toEqual('bar');
    });

    it('autogenerated fields can be specified for all changes to data', ()=>{
        class TAuto extends GizmoData {
            static { Schema.apply(this, 'sdata', { dflt: 1 }); };
            static { Schema.apply(this, 'adata', { autogen: true, setter: (o,x,v) => o.sdata*2 }); };
        };
        let gzd = new TAuto();
        expect(gzd.sdata).toEqual(1);
        expect(gzd.adata).toEqual(2);
        gzd.sdata = 4;
        expect(gzd.sdata).toEqual(4);
        expect(gzd.adata).toEqual(8);
    });

    it('autogenerated fields can be specified for all a specific field', ()=>{
        class TAuto extends GizmoData {
            static { Schema.apply(this, 'sdata1', { dflt: 1 }); };
            static { Schema.apply(this, 'sdata2', { dflt: 2 }); };
            static { Schema.apply(this, 'adata', { autogen: (k) => k === 'sdata1', setter: (o,x,v) => o.sdata1*o.sdata2 }); };
        };
        let gzd = new TAuto();
        expect(gzd.sdata1).toEqual(1);
        expect(gzd.sdata2).toEqual(2);
        expect(gzd.adata).toEqual(2);
        gzd.sdata1 = 4;
        expect(gzd.sdata1).toEqual(4);
        expect(gzd.sdata2).toEqual(2);
        expect(gzd.adata).toEqual(8);
        gzd.sdata2 = 3;
        expect(gzd.sdata1).toEqual(4);
        expect(gzd.sdata2).toEqual(3);
        expect(gzd.adata).toEqual(8);
    });

    it('autogenerated fields can be specified for sub data', ()=>{
        class TSub extends GizmoData {
            static { Schema.apply(this, 'sdata', { dflt: 1 }); };
        };
        class TAuto extends GizmoData {
            static { Schema.apply(this, 'sub', { link: true }); };
            static { Schema.apply(this, 'other', { dflt: 2 }); };
            static { Schema.apply(this, 'adata', { autogen: (k) => k === 'sub', setter: (o,x,v) => o.sub.sdata*o.other }); };
        };
        let gzd = new TAuto({ sub: new TSub() });
        expect(gzd.adata).toEqual(2);
        gzd.sub.sdata = 4;
        expect(gzd.adata).toEqual(8);
        //expect(gzd.sdata1).toEqual(4);
        //expect(gzd.sdata2).toEqual(2);
        //gzd.sdata2 = 3;
        //expect(gzd.sdata1).toEqual(4);
        //expect(gzd.sdata2).toEqual(3);
        //expect(gzd.adata).toEqual(8);
    });

});