export { GizmoData };

import { EvtSystem } from './event.js';
import { Fmt } from './fmt.js';

class GizmoHandle {
    static root(hdl) {
        while (hdl) {
            if (hdl.trunk) {
                hdl = hdl.trunk;
            } else {
                return hdl;
            }
        }
        return null;
    }

    static findInTrunk(hdl, filter) {
        for (let trunk=hdl.trunk; trunk; trunk=trunk.trunk) {
            if (filter(trunk)) return trunk;
        }
        return null;
    }

    static findInPath(hdl, filter) {
        for (let trunk=hdl; trunk; trunk=trunk.trunk) {
            if (filter(trunk)) return trunk;
        }
        return null;
    }

    static path(hdl) {
        let path = null;
        while (hdl.trunk) {
            let key = hdl.keyer();
            path = (path) ? `${key}.${path}` : key;
            hdl = hdl.trunk;
        }
        return path;
    }

    static *eachInPath(hdl, filter) {
        for (; hdl; hdl=hdl.trunk) {
            if (filter(hdl)) yield hdl;
        }
    }

    constructor(node) {
        this.node = node;
        this.trunk = null;
        this.proxy = null;
        this.schema = null;
        this.keyer = () => (this.schema) ? this.schema.key : '';
        this.get = this.iget;
        this.set = this.iset;
        this.pathEventable = EvtSystem.isEmitterCls(node.constructor);
        this.pathUpdatable = false;
        this.pathAutogen = false;
        this.pathReadonly = false;
        this.pathRenderable = false;
        this.finalized = false;
    }

    linkUpdate() {
        let trunk = this.trunk;
        if (trunk) {
            //console.log(`linkUpdate: ${this.constructor.path(this)} schema.eventable: ${this.schema.eventable} trunk.pathEventable: ${trunk.pathEventable}`);
            this.pathEventable = this.schema.eventable && trunk.pathEventable;
            this.pathUpdatable = !this.schema.nopathgen && (this.schema.atUpdate || trunk.pathUpdatable);
            this.pathAutogen = (this.schema.autogendeps.size || trunk.pathAutogen);
            this.pathReadonly = this.schema.readonly || trunk.pathReadonly;
            this.pathRenderable = this.schema.renderable || trunk.pathRenderable;
        } else {
            this.pathEventable = EvtSystem.isEmitter(this.node);
            this.pathUpdatable = false;
            this.pathAutogen = false;
            this.pathReadonly = false;
            this.pathRenderable = false;
        }
        let schemas = this.node.constructor.$schema;
        if (schemas) {
            for (const aschema of schemas.entries) {
                let att = this.node[aschema.key];
                if (att && att instanceof GizmoData) {
                    att.$handle.linkUpdate();
                }
            }
        }
    }

    // -- defines method to set new trunk link
    /**
     * @param {handle} trunk 
     * @param {schema} schema 
     * @param {*} keyer 
     */
    link(trunk, schema, keyer) {
        if (this.constructor.findInPath(trunk.proxy, (gzd) => gzd === this.proxy)) {
            console.error(`hierarchy loop detected ${this.node} already in trunk: ${trunk}`);
            return;
        }
        // set link
        this.trunk = trunk;
        this.schema = schema;
        if (keyer) this.keyer = keyer;
        // update path variables for this node and all dependent branch nodes
        this.linkUpdate()
        this.node.atLink(trunk.proxy);
        // regenerate updates to autogenerated fields
        /*
        for (const agk of this.constructor.$autogenKeys) {
            let agschema = this.constructor.schema[agk];
            if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
            // reset autogenerated value to default, setter will take care of updating value
            if (agk in this) this[agk] = '#autogen#';
        }
        if (this.$pathAutogen) {
            for (const gzt of this.constructor.eachInPath(this, (gzn) => (gzn.$schema && gzn.$schema.autogendeps.size))) {
                for (const agk of gzt.$schema.autogendeps) if (agk in gzt.$trunk) gzt.$trunk[agk] = '#autogen#';
            }
        }
        */

    }

    unlink() {
        let trunk = this.trunk;
        this.trunk = null;
        this.schema = null;
        this.keyer = null;
        this.linkUpdate()
        this.node.atUnlink(trunk);

        // regenerate updates to autogenerated fields
        /*
        for (const agk of this.constructor.$autogenKeys) {
            let agschema = this.constructor.schema[agk];
            if (typeof agschema.autogen === 'function' && !agschema.autogen('$trunk')) continue;
            // reset autogenerated value to default, setter will take care of updating value
            if (agk in this) this[agk] = '#autogen#';
        }
        */

    }
        
    pget(target, key, receiver) {
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return value;
    }
    pset(target, key, value) {
        target[key] = value;
        return true;
    }
    iget(target, key, receiver) {
        //let schema = this.pclass.schema[key];
        let schemas = this.node.constructor.$schema;
        let schema = (schemas) ? schemas.map[key] : null;
        if (schema && schema.getter) return schema.getter(target);
        //console.log(`key: ${key.toString()} this: ${this}`);
        if (key === '$handle') return this;
        if (key === '$target') return target;
        const value = target[key];
        if (value instanceof Function) {
            return function (...args) {
                return value.apply(this === receiver ? target : this, args);
            };
        }
        return target[key];
    };
    iset(target, key, value, force=false) {
        let storedValue = target[key];
        let schemas = this.node.constructor.$schema;
        let schema = (schemas) ? schemas.map[key] : null;
        //let schema = this.node.constructor.$schema.map[key];
        if (schema) {
            if (this.finalized && (schema.readonly || this.pathReadonly)) {
                console.error(`can't set ${key} -- readonly ${schema.readonly} pathRO: ${this.pathReadonly}`);
                return true;
            }
            if (schema.setter) {
                value = schema.setter(target, value);
            }
        }
        if (Object.is(storedValue, value)) return true;
        if (schema) {
            if (schema.link) {
                if (storedValue) storedValue.$handle.unlink();
                target[key] = value;
                if (value) value.$handle.link(this, schema);
            } else {
                target[key] = value;
            }

            if (schema.atUpdate) schema.atUpdate((this.trunk) ? this.trunk.proxy : null, this.proxy, schema.key, storedValue, value);

            // -- path updates are controlled by GizmoData.$pathUpdatable
            if (this.pathUpdatable) {
                for (const hdl of this.constructor.eachInPath(this, (ohdl) => (ohdl.schema && ohdl.schema.atUpdate))) {
                    hdl.schema.atUpdate((hdl.trunk) ? hdl.trunk.proxy : null, this.proxy, schema.key, storedValue, value);
                }
            }

            // handle updates to autogenerated fields associated with this data node
            for (const agk of schema.autogendeps) {
                if (agk in gzd) gzd[agk] = '#autogen#';
            }
            //  autogen updates for linked trunk nodes are controlled by GizmoData.$pathAutogen
            /*
            if (gzd.$pathAutogen) {
                for (const gzt of gzd.constructor.eachInPath(gzd, (gzn) => (gzn.$schema && gzn.$schema.autogendeps.size))) {
                    for (const agk of gzt.$schema.autogendeps) {
                        if (agk in gzt.$trunk) gzt.$trunk[agk] = '#autogen#';
                    }
                }
            }
            */

            // trigger update if attribute is eventable
            //console.log(`iset: ${this.constructor.path(this)} schema: ${schema.key} eventable: ${schema.eventable} path: ${this.pathEventable}`);
            if (schema.eventable && this.pathEventable) {
                // find event emitter in path
                let root = target.constructor.root(this.proxy);
                // emit
                if (EvtSystem.isEmitter(root)) {
                    let path = this.constructor.path(this);
                    let key = (path) ? `${path}.${schema.key}` : schema.key;
                    let renderable = schema.renderable || this.pathRenderable;
                    EvtSystem.trigger(root, 'gizmo.set', { set: { [key]: value }, render: renderable });
                }
            }
        } else {
            target[key] = value;
        }

        return true;
    };
}

class GizmoData {
    static registry = new Map();
    static init() {
        if (!this.registry.has(this.name)) this.registry.set(this.name, this);
    }
    
    /**
     * root returns the root of the given GizmoData structure (if any)
     * @param {GizmoData} gzd - The object to find the root for
     * @returns {GizmoData} - The root of the GizmoData chain (if any)
     */
    static root(gzd) {
        if (gzd && gzd instanceof GizmoData) {
            let node = gzd.$handle.constructor.root(gzd.$handle);
            if (node) return node.proxy;
        }
        return null;
    }

    /**
     * findinTrunk attempts to find a GizmoData node matching the given filter in the trunk (parent nodes) of the given GizmoData object.
     * @param {GizmoData} gzd - The object to start the search at.
     * @param {GizmoData~filter} filter - predicate filter function to apply to each node in the trunk to determine a match
     * @returns {GizmoData} - the first trunk node that matches the filter, otherwise null.
     */
    static findInTrunk(gzd, filter) {
        if (gzd && gzd instanceof GizmoData) {
            let node = gzd.$handle.constructor.findInTrunk(gzd.$handle);
            if (node) return node.proxy;
        }
        return null;
    }

    /**
     * findinPath attempts to find a GizmoData node matching the given filter in the trunk (parent nodes) of the given GizmoData object.
     * @param {GizmoData} gzd - The object to start the search at.
     * @param {GizmoData~filter} filter - predicate filter function to apply to each node in the trunk to determine a match
     * @returns {GizmoData} - the first trunk node that matches the filter, otherwise null.
     */
    static findInPath(gzd, filter) {
        if (filter(gzd)) return gzd;
        return this.findInTrunk(gzd);
    }

    static parser(o, spec, setter) {
        let cls = o.constructor;
        if (cls.$schema) {
            for (const schema of cls.$schema.entries) {
                if (setter) {
                    setter(o, schema.key, schema.parser(o, spec));
                } else {
                    o[schema.key] = schema.parser(o, spec);
                }
            }
        }
    }

    constructor(spec={}) {
        let cls = this.constructor;
        this.constructor.init();
        let handle = new GizmoHandle(this);
        let proxy = new Proxy(this, handle);
        handle.proxy = proxy;
        //console.log(`-- constructor: ${cls}`);
        if (cls.$schema) {
            for (const schema of cls.$schema.entries) {
                handle.set(this, schema.key, schema.parser(this, spec));
            }
        }
        handle.finalized = true;
        return proxy;
    }
    toString() {
        return Fmt.toString(this.constructor.name);
    }

    /**
     * atLink is a method called whenever a GizmoData object is linked to a trunk (parent) data object.  By default, no action is taken.
     * Override this method in a subclass to perform actions when the instance of the data object is linked.
     * @param {GizmoData} trunk - trunk data object that has been linked to the current object.
     */
    atLink(trunk) {
    }
    
    /**
     * atUnlink is a method called whenver a GizmoData object is unlinked from a trunk (parent) data object.  By default, no action is taken.
     * Override this method in a subclass to perform class specific logic when an object is unlinked.
     * @param {GizmoData} trunk - trunk data object that has been linked to the current object.
     */
    atUnlink(trunk) {
    }

}